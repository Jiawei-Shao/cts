{"version":3,"sources":["../../../../../../src/webgpu/api/operation/memory_sync/texture/same_subresource.spec.ts"],"names":["description","SkipTestCase","makeTestGroup","assert","memcpy","unreachable","GPUTest","align","getTextureCopyLayout","kTexelRepresentationInfo","kOperationBoundaries","kBoundaryInfo","kAllReadOps","kAllWriteOps","checkOpsValidForContext","kOpInfo","kOperationContexts","g","TextureSyncTestHelper","currentContext","encodedCommands","kTextureSize","kTextureFormat","constructor","t","textureCreationParams","device","queue","texture","trackForCleanup","createTexture","size","format","performReadOp","op","in","context","ensureContext","usage","GPUTextureUsage","COPY_SRC","COPY_DST","commandEncoder","undefined","copyTextureToTexture","byteLength","bytesPerRow","buffer","createBuffer","GPUBufferUsage","copyTextureToBuffer","copyBufferToTexture","performWriteOp","data","renderPassEncoder","beginRenderPass","colorAttachments","view","createView","loadValue","R","G","B","A","storeOp","rep","texelData","pack","encode","numTexels","fullTexelData","ArrayBuffer","i","src","dst","start","writeTexture","j","writeBuffer","ensureSubmit","flushEncodedCommands","popContext","commandBuffer","finish","computePassEncoder","endPass","renderBundleEncoder","renderBundle","makeDummyAttachment","RENDER_ATTACHMENT","ancestorContext","Math","min","indexOf","result","GPURenderBundle","length","push","GPUCommandBuffer","createCommandEncoder","beginComputePass","createRenderBundleEncoder","colorFormats","executeBundles","submit","ensureBoundary","boundary","test","desc","params","u","combine","expand","p","contexts","expandWithParams","_context","read","write","fn","helper","readUsage","writeUsage","texelValue1","texelValue2","readbackTexture","expectSingleColor","exp","texelValue","first","second","unimplemented"],"mappings":";AAAA;AACA,GADA,OAAO,MAAMA,WAAW,GAAI;AAC5B;AACA;AACA;AACA;AACA;AACA,CANO,CAQP,SAASC,YAAT,QAA6B,4CAA7B;AACA,SAASC,aAAT,QAA8B,+CAA9B;AACA,SAASC,MAAT,EAAiBC,MAAjB,EAAyBC,WAAzB,QAA4C,oCAA5C;;AAEA,SAASC,OAAT,QAAwB,yBAAxB;AACA,SAASC,KAAT,QAAsB,0BAAtB;AACA,SAASC,oBAAT,QAAqC,oCAArC;AACA;AACEC,wBADF;;AAGO,wCAHP;;AAKA;AACEC,oBADF;AAEEC,aAFF;AAGEC,WAHF;AAIEC,YAJF;AAKEC,uBALF;;;;AASEC,OATF;AAUEC,kBAVF;AAWO,wBAXP;;AAaA,OAAO,MAAMC,CAAC,GAAGf,aAAa,CAACI,OAAD,CAAvB;;AAEP,MAAMY,qBAAN,CAA4B;AAC1B;AACQC,EAAAA,cAAR,GAA2C,OAA3C;;AAEA;;;;;;;;;;;AAWQC,EAAAA,eAAR,GAAkE,EAAlE;;AAEgBC,EAAAA,YAAhB,GAA+B,CAAC,CAAD,EAAI,CAAJ,CAA/B;AACgBC,EAAAA,cAAhB,GAAyD,YAAzD;;AAEAC,EAAAA,WAAW;AACTC,EAAAA,CADS;AAETC,EAAAA,qBAFS;;;AAKT;AACA,SAAKD,CAAL,GAASA,CAAT;AACA,SAAKE,MAAL,GAAcF,CAAC,CAACE,MAAhB;AACA,SAAKC,KAAL,GAAaH,CAAC,CAACE,MAAF,CAASC,KAAtB;AACA,SAAKC,OAAL,GAAeJ,CAAC,CAACK,eAAF;AACbL,IAAAA,CAAC,CAACE,MAAF,CAASI,aAAT,CAAuB;AACrBC,MAAAA,IAAI,EAAE,KAAKV,YADU;AAErBW,MAAAA,MAAM,EAAE,KAAKV,cAFQ;AAGrB,SAAGG,qBAHkB,EAAvB,CADa,CAAf;;;AAOD;;AAED;AACF;AACA;AACA;AACEQ,EAAAA,aAAa,CAAC,EAAEC,EAAF,EAAMC,EAAE,EAAEC,OAAV,EAAD,EAAoE;AAC/E,SAAKC,aAAL,CAAmBD,OAAnB;AACA,YAAQF,EAAR;AACE,WAAK,UAAL,CAAiB;AACf,gBAAMN,OAAO,GAAG,KAAKJ,CAAL,CAAOK,eAAP;AACd,eAAKH,MAAL,CAAYI,aAAZ,CAA0B;AACxBC,YAAAA,IAAI,EAAE,KAAKV,YADa;AAExBW,YAAAA,MAAM,EAAE,KAAKV,cAFW;AAGxBgB,YAAAA,KAAK,EAAEC,eAAe,CAACC,QAAhB,GAA2BD,eAAe,CAACE,QAH1B,EAA1B,CADc,CAAhB;;;;AAQAtC,UAAAA,MAAM,CAAC,KAAKuC,cAAL,KAAwBC,SAAzB,CAAN;AACA,eAAKD,cAAL,CAAoBE,oBAApB;AACE;AACEhB,YAAAA,OAAO,EAAE,KAAKA,OADhB,EADF;;AAIE,YAAEA,OAAF,EAJF;AAKE,eAAKP,YALP;;AAOA,iBAAOO,OAAP;AACD;AACD,WAAK,UAAL,CAAiB;AACf,gBAAM,EAAEiB,UAAF,EAAcC,WAAd,KAA8BtC,oBAAoB,CAAC,KAAKc,cAAN,EAAsB,IAAtB,EAA4B;AAClF,aAAG,KAAKD,YAD0E;AAElF,WAFkF,CAA5B,CAAxD;;AAIA,gBAAM0B,MAAM,GAAG,KAAKvB,CAAL,CAAOK,eAAP;AACb,eAAKH,MAAL,CAAYsB,YAAZ,CAAyB;AACvBjB,YAAAA,IAAI,EAAEc,UADiB;AAEvBP,YAAAA,KAAK,EAAEW,cAAc,CAACT,QAAf,GAA0BS,cAAc,CAACR,QAFzB,EAAzB,CADa,CAAf;;;;AAOA,gBAAMb,OAAO,GAAG,KAAKJ,CAAL,CAAOK,eAAP;AACd,eAAKH,MAAL,CAAYI,aAAZ,CAA0B;AACxBC,YAAAA,IAAI,EAAE,KAAKV,YADa;AAExBW,YAAAA,MAAM,EAAE,KAAKV,cAFW;AAGxBgB,YAAAA,KAAK,EAAEC,eAAe,CAACC,QAAhB,GAA2BD,eAAe,CAACE,QAH1B,EAA1B,CADc,CAAhB;;;;AAQAtC,UAAAA,MAAM,CAAC,KAAKuC,cAAL,KAAwBC,SAAzB,CAAN;AACA,eAAKD,cAAL,CAAoBQ,mBAApB;AACE;AACEtB,YAAAA,OAAO,EAAE,KAAKA,OADhB,EADF;;AAIE,YAAEmB,MAAF,EAAUD,WAAV,EAJF;AAKE,eAAKzB,YALP;;AAOA,eAAKqB,cAAL,CAAoBS,mBAApB;AACE,YAAEJ,MAAF,EAAUD,WAAV,EADF;AAEE,YAAElB,OAAF,EAFF;AAGE,eAAKP,YAHP;;AAKA,iBAAOO,OAAP;AACD;AACD,WAAK,QAAL;AACA,WAAK,SAAL;AACE;AACA,cAAM,IAAI3B,YAAJ,CAAiB,eAAjB,CAAN;AACA;AACF,WAAK,UAAL;AACA,WAAK,oBAAL;AACA,WAAK,kBAAL;AACEI,QAAAA,WAAW,GA/Df;;AAiEAA,IAAAA,WAAW;AACZ;;AAED+C,EAAAA,cAAc;AACZ,IAAElB,EAAF,EAAMC,EAAE,EAAEC,OAAV,EADY;AAEZiB,EAAAA,IAFY;AAGZ;AACA,SAAKhB,aAAL,CAAmBD,OAAnB;AACA,YAAQF,EAAR;AACE,WAAK,kBAAL,CAAyB;AACvB/B,UAAAA,MAAM,CAAC,KAAKuC,cAAL,KAAwBC,SAAzB,CAAN;AACA,eAAKW,iBAAL,GAAyB,KAAKZ,cAAL,CAAoBa,eAApB,CAAoC;AAC3DC,YAAAA,gBAAgB,EAAE;AAChB;AACEC,cAAAA,IAAI,EAAE,KAAK7B,OAAL,CAAa8B,UAAb,EADR;AAEE;AACAC,cAAAA,SAAS,EAAE,CAACN,IAAI,CAACO,CAAL,IAAU,CAAX,EAAcP,IAAI,CAACQ,CAAL,IAAU,CAAxB,EAA2BR,IAAI,CAACS,CAAL,IAAU,CAArC,EAAwCT,IAAI,CAACU,CAAL,IAAU,CAAlD,CAHb;AAIEC,cAAAA,OAAO,EAAE,OAJX,EADgB,CADyC,EAApC,CAAzB;;;;AAUA,eAAK7C,cAAL,GAAsB,qBAAtB;AACA;AACD;AACD,WAAK,eAAL,CAAsB;AACpB;AACA,gBAAM8C,GAAG,GAAGxD,wBAAwB,CAAC,KAAKa,cAAN,CAApC;AACA,gBAAM4C,SAAS,GAAGD,GAAG,CAACE,IAAJ,CAASF,GAAG,CAACG,MAAJ,CAAWf,IAAX,CAAT,CAAlB;AACA,gBAAMgB,SAAS,GAAG,KAAKhD,YAAL,CAAkB,CAAlB,IAAuB,KAAKA,YAAL,CAAkB,CAAlB,CAAzC;AACA,gBAAMiD,aAAa,GAAG,IAAIC,WAAJ,CAAgBL,SAAS,CAACrB,UAAV,GAAuBwB,SAAvC,CAAtB;AACA,eAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,SAApB,EAA+B,EAAEG,CAAjC,EAAoC;AAClCpE,YAAAA,MAAM,CAAC,EAAEqE,GAAG,EAAEP,SAAP,EAAD,EAAqB,EAAEQ,GAAG,EAAEJ,aAAP,EAAsBK,KAAK,EAAEH,CAAC,GAAGN,SAAS,CAACrB,UAA3C,EAArB,CAAN;AACD;;AAED,eAAKlB,KAAL,CAAWiD,YAAX;AACE,YAAEhD,OAAO,EAAE,KAAKA,OAAhB,EADF;AAEE0C,UAAAA,aAFF;AAGE;AACExB,YAAAA,WAAW,EAAEoB,SAAS,CAACrB,UAAV,GAAuB,KAAKxB,YAAL,CAAkB,CAAlB,CADtC,EAHF;;AAME,eAAKA,YANP;;AAQA;AACD;AACD,WAAK,UAAL,CAAiB;AACf,gBAAMO,OAAO,GAAG,KAAKF,MAAL,CAAYI,aAAZ,CAA0B;AACxCC,YAAAA,IAAI,EAAE,KAAKV,YAD6B;AAExCW,YAAAA,MAAM,EAAE,KAAKV,cAF2B;AAGxCgB,YAAAA,KAAK,EAAEC,eAAe,CAACC,QAAhB,GAA2BD,eAAe,CAACE,QAHV,EAA1B,CAAhB;;;AAMA;AACA,gBAAMwB,GAAG,GAAGxD,wBAAwB,CAAC,KAAKa,cAAN,CAApC;AACA,gBAAM4C,SAAS,GAAGD,GAAG,CAACE,IAAJ,CAASF,GAAG,CAACG,MAAJ,CAAWf,IAAX,CAAT,CAAlB;AACA,gBAAMgB,SAAS,GAAG,KAAKhD,YAAL,CAAkB,CAAlB,IAAuB,KAAKA,YAAL,CAAkB,CAAlB,CAAzC;AACA,gBAAMiD,aAAa,GAAG,IAAIC,WAAJ,CAAgBL,SAAS,CAACrB,UAAV,GAAuBwB,SAAvC,CAAtB;AACA,eAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,SAApB,EAA+B,EAAEG,CAAjC,EAAoC;AAClCpE,YAAAA,MAAM,CAAC,EAAEqE,GAAG,EAAEP,SAAP,EAAD,EAAqB,EAAEQ,GAAG,EAAEJ,aAAP,EAAsBK,KAAK,EAAEH,CAAC,GAAGN,SAAS,CAACrB,UAA3C,EAArB,CAAN;AACD;;AAED,eAAKlB,KAAL,CAAWiD,YAAX;AACE,YAAEhD,OAAF,EADF;AAEE0C,UAAAA,aAFF;AAGE;AACExB,YAAAA,WAAW,EAAEoB,SAAS,CAACrB,UAAV,GAAuB,KAAKxB,YAAL,CAAkB,CAAlB,CADtC,EAHF;;AAME,eAAKA,YANP;;;AASAlB,UAAAA,MAAM,CAAC,KAAKuC,cAAL,KAAwBC,SAAzB,CAAN;AACA,eAAKD,cAAL,CAAoBE,oBAApB;AACE,YAAEhB,OAAF,EADF;AAEE,YAAEA,OAAO,EAAE,KAAKA,OAAhB,EAFF;AAGE,eAAKP,YAHP;;AAKA;AACD;AACD,WAAK,UAAL,CAAiB;AACf;AACA,gBAAM4C,GAAG,GAAGxD,wBAAwB,CAAC,KAAKa,cAAN,CAApC;AACA,gBAAM4C,SAAS,GAAGD,GAAG,CAACE,IAAJ,CAASF,GAAG,CAACG,MAAJ,CAAWf,IAAX,CAAT,CAAlB;AACA,gBAAMP,WAAW,GAAGvC,KAAK,CAAC2D,SAAS,CAACrB,UAAX,EAAuB,GAAvB,CAAzB;AACA,gBAAMyB,aAAa,GAAG,IAAIC,WAAJ,CAAgBzB,WAAW,GAAG,KAAKzB,YAAL,CAAkB,CAAlB,CAA9B,CAAtB;AACA,eAAK,IAAImD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKnD,YAAL,CAAkB,CAAlB,CAApB,EAA0C,EAAEmD,CAA5C,EAA+C;AAC7C,iBAAK,IAAIK,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKxD,YAAL,CAAkB,CAAlB,CAApB,EAA0C,EAAEwD,CAA5C,EAA+C;AAC7CzE,cAAAA,MAAM;AACJ,gBAAEqE,GAAG,EAAEP,SAAP,EADI;AAEJ;AACEQ,gBAAAA,GAAG,EAAEJ,aADP;AAEEK,gBAAAA,KAAK,EAAEH,CAAC,GAAG1B,WAAJ,GAAkB+B,CAAC,GAAGX,SAAS,CAACrB,UAFzC,EAFI,CAAN;;;AAOD;AACF;;AAED,gBAAME,MAAM,GAAG,KAAKvB,CAAL,CAAOK,eAAP;AACb,eAAKH,MAAL,CAAYsB,YAAZ,CAAyB;AACvBjB,YAAAA,IAAI,EAAEuC,aAAa,CAACzB,UADG;AAEvBP,YAAAA,KAAK,EAAEW,cAAc,CAACT,QAAf,GAA0BS,cAAc,CAACR,QAFzB,EAAzB,CADa,CAAf;;;;AAOA,eAAKd,KAAL,CAAWmD,WAAX,CAAuB/B,MAAvB,EAA+B,CAA/B,EAAkCuB,aAAlC;;AAEAnE,UAAAA,MAAM,CAAC,KAAKuC,cAAL,KAAwBC,SAAzB,CAAN;AACA,eAAKD,cAAL,CAAoBS,mBAApB;AACE,YAAEJ,MAAF,EAAUD,WAAV,EADF;AAEE,YAAElB,OAAO,EAAE,KAAKA,OAAhB,EAFF;AAGE,eAAKP,YAHP;;AAKA;AACD;AACD,WAAK,oBAAL;AACA,WAAK,SAAL;AACE;AACA,cAAM,IAAIpB,YAAJ,CAAiB,eAAjB,CAAN;AACF,WAAK,UAAL;AACA,WAAK,QAAL;AACEI,QAAAA,WAAW,GA9Gf;;AAgHD;;AAED;AACA0E,EAAAA,YAAY,GAAG;AACb,SAAK1C,aAAL,CAAmB,OAAnB;AACA,SAAK2C,oBAAL;AACD;;AAEOC,EAAAA,UAAR,GAAgE;AAC9D,YAAQ,KAAK9D,cAAb;AACE,WAAK,OAAL;AACEd,QAAAA,WAAW;AACX;AACF,WAAK,iBAAL,CAAwB;AACtBF,UAAAA,MAAM,CAAC,KAAKuC,cAAL,KAAwBC,SAAzB,CAAN;AACA,gBAAMuC,aAAa,GAAG,KAAKxC,cAAL,CAAoByC,MAApB,EAAtB;AACA,eAAKzC,cAAL,GAAsBC,SAAtB;AACA,eAAKxB,cAAL,GAAsB,OAAtB;AACA,iBAAO+D,aAAP;AACD;AACD,WAAK,sBAAL;AACE/E,QAAAA,MAAM,CAAC,KAAKiF,kBAAL,KAA4BzC,SAA7B,CAAN;AACA,aAAKyC,kBAAL,CAAwBC,OAAxB;AACA,aAAKD,kBAAL,GAA0BzC,SAA1B;AACA,aAAKxB,cAAL,GAAsB,iBAAtB;AACA;AACF,WAAK,qBAAL;AACEhB,QAAAA,MAAM,CAAC,KAAKmD,iBAAL,KAA2BX,SAA5B,CAAN;AACA,aAAKW,iBAAL,CAAuB+B,OAAvB;AACA,aAAK/B,iBAAL,GAAyBX,SAAzB;AACA,aAAKxB,cAAL,GAAsB,iBAAtB;AACA;AACF,WAAK,uBAAL,CAA8B;AAC5BhB,UAAAA,MAAM,CAAC,KAAKmF,mBAAL,KAA6B3C,SAA9B,CAAN;AACA,gBAAM4C,YAAY,GAAG,KAAKD,mBAAL,CAAyBH,MAAzB,EAArB;AACA,eAAKG,mBAAL,GAA2B3C,SAA3B;AACA,eAAKxB,cAAL,GAAsB,qBAAtB;AACA,iBAAOoE,YAAP;AACD,SA7BH;;AA+BA,WAAO,IAAP;AACD;;AAEOC,EAAAA,mBAAR,GAA4D;AAC1D,UAAM5D,OAAO,GAAG,KAAKJ,CAAL,CAAOK,eAAP;AACd,SAAKH,MAAL,CAAYI,aAAZ,CAA0B;AACxBE,MAAAA,MAAM,EAAE,KAAKV,cADW;AAExBS,MAAAA,IAAI,EAAE,KAAKV,YAFa;AAGxBiB,MAAAA,KAAK,EAAEC,eAAe,CAACkD,iBAHC,EAA1B,CADc,CAAhB;;;AAOA,WAAO;AACLhC,MAAAA,IAAI,EAAE7B,OAAO,CAAC8B,UAAR,EADD;AAELC,MAAAA,SAAS,EAAE,MAFN;AAGLK,MAAAA,OAAO,EAAE,OAHJ,EAAP;;AAKD;;AAEO3B,EAAAA,aAAR,CAAsBD,OAAtB,EAAiD;AAC/C;AACA,UAAMsD,eAAe;AACnB1E,IAAAA,kBAAkB;AAChB2E,IAAAA,IAAI,CAACC,GAAL;AACE5E,IAAAA,kBAAkB,CAAC6E,OAAnB,CAA2BzD,OAA3B,CADF;AAEEpB,IAAAA,kBAAkB,CAAC6E,OAAnB,CAA2B,KAAK1E,cAAhC,CAFF,CADgB,CADpB;;;;AAQA;AACA,WAAO,KAAKA,cAAL,KAAwBuE,eAA/B,EAAgD;AAC9C;AACA,UAAI,KAAKvE,cAAL,KAAwB,qBAA5B,EAAmD;AACjD,aAAK6D,oBAAL;AACD;;AAED,YAAMc,MAAM,GAAG,KAAKb,UAAL,EAAf;AACA,UAAIa,MAAJ,EAAY;AACV,YAAIA,MAAM,YAAYC,eAAtB,EAAuC;AACrC5F,UAAAA,MAAM;AACJ,eAAKiB,eAAL,CAAqB4E,MAArB,KAAgC,CAAhC,IAAqC,KAAK5E,eAAL,CAAqB,CAArB,aAAmC2E,eADpE,CAAN;;AAGC,eAAK3E,eAAN,CAA4C6E,IAA5C,CAAiDH,MAAjD;AACD,SALD,MAKO;AACL3F,UAAAA,MAAM;AACJ,eAAKiB,eAAL,CAAqB4E,MAArB,KAAgC,CAAhC,IAAqC,KAAK5E,eAAL,CAAqB,CAArB,aAAmC8E,gBADpE,CAAN;;AAGC,eAAK9E,eAAN,CAA6C6E,IAA7C,CAAkDH,MAAlD;AACD;AACF;AACF;;AAED,QAAI,KAAK3E,cAAL,KAAwBiB,OAA5B,EAAqC;AACnC;AACD;;AAED,YAAQA,OAAR;AACE,WAAK,OAAL;AACE/B,QAAAA,WAAW;AACX;AACF,WAAK,iBAAL;AACEF,QAAAA,MAAM,CAAC,KAAKgB,cAAL,KAAwB,OAAzB,CAAN;AACA,aAAKuB,cAAL,GAAsB,KAAKhB,MAAL,CAAYyE,oBAAZ,EAAtB;AACA;AACF,WAAK,sBAAL;AACE,gBAAQ,KAAKhF,cAAb;AACE,eAAK,OAAL;AACE,iBAAKuB,cAAL,GAAsB,KAAKhB,MAAL,CAAYyE,oBAAZ,EAAtB;AACF;AACA,eAAK,iBAAL;AACEhG,YAAAA,MAAM,CAAC,KAAKuC,cAAL,KAAwBC,SAAzB,CAAN;AACA,iBAAKyC,kBAAL,GAA0B,KAAK1C,cAAL,CAAoB0D,gBAApB,EAA1B;AACA;AACF,eAAK,sBAAL;AACA,eAAK,uBAAL;AACA,eAAK,qBAAL;AACE/F,YAAAA,WAAW,GAXf;;AAaA;AACF,WAAK,qBAAL;AACE,gBAAQ,KAAKc,cAAb;AACE,eAAK,OAAL;AACE,iBAAKuB,cAAL,GAAsB,KAAKhB,MAAL,CAAYyE,oBAAZ,EAAtB;AACF;AACA,eAAK,iBAAL;AACEhG,YAAAA,MAAM,CAAC,KAAKuC,cAAL,KAAwBC,SAAzB,CAAN;AACA,iBAAKW,iBAAL,GAAyB,KAAKZ,cAAL,CAAoBa,eAApB,CAAoC;AAC3DC,cAAAA,gBAAgB,EAAE,CAAC,KAAKgC,mBAAL,EAAD,CADyC,EAApC,CAAzB;;AAGA;AACF,eAAK,qBAAL;AACA,eAAK,uBAAL;AACA,eAAK,sBAAL;AACEnF,YAAAA,WAAW,GAbf;;AAeA;AACF,WAAK,uBAAL;AACE,gBAAQ,KAAKc,cAAb;AACE,eAAK,OAAL;AACE,iBAAKuB,cAAL,GAAsB,KAAKhB,MAAL,CAAYyE,oBAAZ,EAAtB;AACF;AACA,eAAK,iBAAL;AACEhG,YAAAA,MAAM,CAAC,KAAKuC,cAAL,KAAwBC,SAAzB,CAAN;AACA,iBAAKW,iBAAL,GAAyB,KAAKZ,cAAL,CAAoBa,eAApB,CAAoC;AAC3DC,cAAAA,gBAAgB,EAAE,CAAC,KAAKgC,mBAAL,EAAD,CADyC,EAApC,CAAzB;;AAGF;AACA,eAAK,qBAAL;AACE,iBAAKF,mBAAL,GAA2B,KAAK5D,MAAL,CAAY2E,yBAAZ,CAAsC;AAC/DC,cAAAA,YAAY,EAAE,CAAC,KAAKhF,cAAN,CADiD,EAAtC,CAA3B;;AAGA;AACF,eAAK,uBAAL;AACA,eAAK,sBAAL;AACEjB,YAAAA,WAAW,GAjBf;;AAmBA,cA5DJ;;AA8DA,SAAKc,cAAL,GAAsBiB,OAAtB;AACD;;AAED;AACF;AACA;AACU4C,EAAAA,oBAAR,GAA+B;AAC7B,QAAI,KAAK5D,eAAL,CAAqB4E,MAArB,GAA8B,CAAlC,EAAqC;AACnC,UAAI,KAAK5E,eAAL,CAAqB,CAArB,aAAmC2E,eAAvC,EAAwD;AACtD5F,QAAAA,MAAM,CAAC,KAAKmD,iBAAL,KAA2BX,SAA5B,CAAN;AACA,aAAKW,iBAAL,CAAuBiD,cAAvB,CAAsC,KAAKnF,eAA3C;AACD,OAHD,MAGO;AACL,aAAKO,KAAL,CAAW6E,MAAX,CAAkB,KAAKpF,eAAvB;AACD;AACF;AACD,SAAKA,eAAL,GAAuB,EAAvB;AACD;;AAEDqF,EAAAA,cAAc,CAACC,QAAD,EAA8B;AAC1C,YAAQA,QAAR;AACE,WAAK,gBAAL;AACE,aAAKrE,aAAL,CAAmB,OAAnB;AACA;AACF,WAAK,UAAL;AACE,aAAKA,aAAL,CAAmB,OAAnB;AACA;AACA,aAAK2C,oBAAL;AACA;AACF,WAAK,UAAL;AACE;AACA7E,QAAAA,MAAM,CAAC,KAAKgB,cAAL,KAAwB,sBAAzB,CAAN;AACA;AACF,WAAK,MAAL;AACE;AACAhB,QAAAA,MAAM;AACJ,aAAKgB,cAAL,KAAwB,qBAAxB;AACE,aAAKA,cAAL,KAAwB,uBAFtB,CAAN;;AAIA;AACF,WAAK,MAAL;AACE,aAAKkB,aAAL,CAAmB,iBAAnB;AACA;AACF,WAAK,eAAL;AACE,aAAKA,aAAL,CAAmB,qBAAnB;AACA;AACF,WAAK,iBAAL;AACE,aAAKA,aAAL,CAAmB,qBAAnB;AACA;AACA,aAAK2C,oBAAL;AACA,cA9BJ;;AAgCD,GArbyB;;;AAwb5B/D,CAAC,CAAC0F,IAAF,CAAO,IAAP;AACGC,IADH;AAEK;AACL;AACA;AACA;AACA,0EANA;;AAQGC,MARH,CAQU,CAAAC,CAAC;AACPA,CAAC;AACEC,OADH,CACW,UADX,EACuBrG,oBADvB;AAEGsG,MAFH,CAEU,UAFV,EAEsBC,CAAC,IAAItG,aAAa,CAACsG,CAAC,CAACP,QAAH,CAAb,CAA0BQ,QAFrD;AAGGC,gBAHH,CAGoB,WAAW,EAAEC,QAAF,EAAX,EAAyB;AACzC,OAAK,MAAMC,IAAX,IAAmBzG,WAAnB,EAAgC;AAC9B,SAAK,MAAM0G,KAAX,IAAoBzG,YAApB,EAAkC;AAChC,UAAIC,uBAAuB,CAAC,CAACuG,IAAD,EAAOC,KAAP,CAAD,EAAgBF,QAAhB,CAA3B,EAAsD;AACpD,cAAM;AACJC,UAAAA,IAAI,EAAE,EAAEnF,EAAE,EAAEmF,IAAN,EAAYlF,EAAE,EAAEiF,QAAQ,CAAC,CAAD,CAAxB,EADF;AAEJE,UAAAA,KAAK,EAAE,EAAEpF,EAAE,EAAEoF,KAAN,EAAanF,EAAE,EAAEiF,QAAQ,CAAC,CAAD,CAAzB,EAFH,EAAN;;AAID;AACF;AACF;AACF,CAdH,CATJ;;AAyBGG,EAzBH,CAyBM/F,CAAC,IAAI;AACP,QAAMgG,MAAM,GAAG,IAAItG,qBAAJ,CAA0BM,CAA1B,EAA6B;AAC1Cc,IAAAA,KAAK;AACHC,IAAAA,eAAe,CAACE,QAAhB;AACA1B,IAAAA,OAAO,CAACS,CAAC,CAACqF,MAAF,CAASQ,IAAT,CAAcnF,EAAf,CAAP,CAA0BuF,SAD1B;AAEA1G,IAAAA,OAAO,CAACS,CAAC,CAACqF,MAAF,CAASS,KAAT,CAAepF,EAAhB,CAAP,CAA2BwF,UAJa,EAA7B,CAAf;;AAMA;AACA,QAAMC,WAAW,GAAG,EAAE/D,CAAC,EAAE,CAAL,EAAQC,CAAC,EAAE,CAAX,EAAcC,CAAC,EAAE,CAAjB,EAAoBC,CAAC,EAAE,CAAvB,EAApB;AACA,QAAM6D,WAAW,GAAG,EAAEhE,CAAC,EAAE,CAAL,EAAQC,CAAC,EAAE,CAAX,EAAcC,CAAC,EAAE,CAAjB,EAAoBC,CAAC,EAAE,CAAvB,EAApB;;AAEA;AACAyD,EAAAA,MAAM,CAACpE,cAAP,CAAsB,EAAElB,EAAE,EAAE,eAAN,EAAuBC,EAAE,EAAE,OAA3B,EAAtB,EAA4DwF,WAA5D;AACA,QAAME,eAAe,GAAGL,MAAM,CAACvF,aAAP,CAAqBT,CAAC,CAACqF,MAAF,CAASQ,IAA9B,CAAxB;AACAG,EAAAA,MAAM,CAACf,cAAP,CAAsBjF,CAAC,CAACqF,MAAF,CAASH,QAA/B;AACAc,EAAAA,MAAM,CAACpE,cAAP,CAAsB5B,CAAC,CAACqF,MAAF,CAASS,KAA/B,EAAsCM,WAAtC;AACAJ,EAAAA,MAAM,CAACzC,YAAP;;AAEA;AACAvD,EAAAA,CAAC,CAACsG,iBAAF,CAAoBD,eAApB,EAAqCL,MAAM,CAAClG,cAA5C,EAA4D;AAC1DS,IAAAA,IAAI,EAAE,CAAC,GAAGyF,MAAM,CAACnG,YAAX,EAAyB,CAAzB,CADoD;AAE1D0G,IAAAA,GAAG,EAAEJ,WAFqD,EAA5D;;AAID,CAhDH;;AAkDA1G,CAAC,CAAC0F,IAAF,CAAO,IAAP;AACGC,IADH;AAEK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,qDATA;;AAWGC,MAXH,CAWU,CAAAC,CAAC;AACPA,CAAC;AACEC,OADH,CACW,UADX,EACuBrG,oBADvB;AAEGsG,MAFH,CAEU,UAFV,EAEsBC,CAAC,IAAItG,aAAa,CAACsG,CAAC,CAACP,QAAH,CAAb,CAA0BQ,QAFrD;AAGGC,gBAHH,CAGoB,WAAW,EAAEC,QAAF,EAAX,EAAyB;AACzC,OAAK,MAAMC,IAAX,IAAmBzG,WAAnB,EAAgC;AAC9B,SAAK,MAAM0G,KAAX,IAAoBzG,YAApB,EAAkC;AAChC,UAAIC,uBAAuB,CAAC,CAACwG,KAAD,EAAQD,IAAR,CAAD,EAAgBD,QAAhB,CAA3B,EAAsD;AACpD,cAAM;AACJE,UAAAA,KAAK,EAAE,EAAEpF,EAAE,EAAEoF,KAAN,EAAanF,EAAE,EAAEiF,QAAQ,CAAC,CAAD,CAAzB,EADH;AAEJC,UAAAA,IAAI,EAAE,EAAEnF,EAAE,EAAEmF,IAAN,EAAYlF,EAAE,EAAEiF,QAAQ,CAAC,CAAD,CAAxB,EAFF,EAAN;;AAID;AACF;AACF;AACF,CAdH,CAZJ;;AA4BGG,EA5BH,CA4BM/F,CAAC,IAAI;AACP,QAAMgG,MAAM,GAAG,IAAItG,qBAAJ,CAA0BM,CAA1B,EAA6B;AAC1Cc,IAAAA,KAAK,EAAEvB,OAAO,CAACS,CAAC,CAACqF,MAAF,CAASQ,IAAT,CAAcnF,EAAf,CAAP,CAA0BuF,SAA1B,GAAsC1G,OAAO,CAACS,CAAC,CAACqF,MAAF,CAASS,KAAT,CAAepF,EAAhB,CAAP,CAA2BwF,UAD9B,EAA7B,CAAf;;AAGA;AACA,QAAMM,UAAU,GAAG,EAAEpE,CAAC,EAAE,CAAL,EAAQC,CAAC,EAAE,CAAX,EAAcC,CAAC,EAAE,CAAjB,EAAoBC,CAAC,EAAE,CAAvB,EAAnB;;AAEAyD,EAAAA,MAAM,CAACpE,cAAP,CAAsB5B,CAAC,CAACqF,MAAF,CAASS,KAA/B,EAAsCU,UAAtC;AACAR,EAAAA,MAAM,CAACf,cAAP,CAAsBjF,CAAC,CAACqF,MAAF,CAASH,QAA/B;AACA,QAAMmB,eAAe,GAAGL,MAAM,CAACvF,aAAP,CAAqBT,CAAC,CAACqF,MAAF,CAASQ,IAA9B,CAAxB;AACAG,EAAAA,MAAM,CAACzC,YAAP;;AAEA;AACAvD,EAAAA,CAAC,CAACsG,iBAAF,CAAoBD,eAApB,EAAqCL,MAAM,CAAClG,cAA5C,EAA4D;AAC1DS,IAAAA,IAAI,EAAE,CAAC,GAAGyF,MAAM,CAACnG,YAAX,EAAyB,CAAzB,CADoD;AAE1D0G,IAAAA,GAAG,EAAEC,UAFqD,EAA5D;;AAID,CA7CH;;AA+CA/G,CAAC,CAAC0F,IAAF,CAAO,IAAP;AACGC,IADH;AAEK;AACL;AACA;AACA;AACA,iEANA;;AAQGC,MARH,CAQU,CAAAC,CAAC;AACPA,CAAC;AACEC,OADH,CACW,UADX,EACuBrG,oBADvB;AAEGsG,MAFH,CAEU,UAFV,EAEsBC,CAAC,IAAItG,aAAa,CAACsG,CAAC,CAACP,QAAH,CAAb,CAA0BQ,QAFrD;AAGGC,gBAHH,CAGoB,WAAW,EAAEC,QAAF,EAAX,EAAyB;AACzC,OAAK,MAAMa,KAAX,IAAoBpH,YAApB,EAAkC;AAChC,SAAK,MAAMqH,MAAX,IAAqBrH,YAArB,EAAmC;AACjC,UAAIC,uBAAuB,CAAC,CAACmH,KAAD,EAAQC,MAAR,CAAD,EAAkBd,QAAlB,CAA3B,EAAwD;AACtD,cAAM;AACJa,UAAAA,KAAK,EAAE,EAAE/F,EAAE,EAAE+F,KAAN,EAAa9F,EAAE,EAAEiF,QAAQ,CAAC,CAAD,CAAzB,EADH;AAEJc,UAAAA,MAAM,EAAE,EAAEhG,EAAE,EAAEgG,MAAN,EAAc/F,EAAE,EAAEiF,QAAQ,CAAC,CAAD,CAA1B,EAFJ,EAAN;;AAID;AACF;AACF;AACF,CAdH,CATJ;;AAyBGG,EAzBH,CAyBM/F,CAAC,IAAI;AACP,QAAMgG,MAAM,GAAG,IAAItG,qBAAJ,CAA0BM,CAA1B,EAA6B;AAC1Cc,IAAAA,KAAK;AACHC,IAAAA,eAAe,CAACC,QAAhB;AACAzB,IAAAA,OAAO,CAACS,CAAC,CAACqF,MAAF,CAASoB,KAAT,CAAe/F,EAAhB,CAAP,CAA2BwF,UAD3B;AAEA3G,IAAAA,OAAO,CAACS,CAAC,CAACqF,MAAF,CAASqB,MAAT,CAAgBhG,EAAjB,CAAP,CAA4BwF,UAJY,EAA7B,CAAf;;AAMA;AACA,QAAMC,WAAW,GAAG,EAAE/D,CAAC,EAAE,CAAL,EAAQC,CAAC,EAAE,CAAX,EAAcC,CAAC,EAAE,CAAjB,EAAoBC,CAAC,EAAE,CAAvB,EAApB;AACA,QAAM6D,WAAW,GAAG,EAAEhE,CAAC,EAAE,CAAL,EAAQC,CAAC,EAAE,CAAX,EAAcC,CAAC,EAAE,CAAjB,EAAoBC,CAAC,EAAE,CAAvB,EAApB;;AAEAyD,EAAAA,MAAM,CAACpE,cAAP,CAAsB5B,CAAC,CAACqF,MAAF,CAASoB,KAA/B,EAAsCN,WAAtC;AACAH,EAAAA,MAAM,CAACf,cAAP,CAAsBjF,CAAC,CAACqF,MAAF,CAASH,QAA/B;AACAc,EAAAA,MAAM,CAACpE,cAAP,CAAsB5B,CAAC,CAACqF,MAAF,CAASqB,MAA/B,EAAuCN,WAAvC;AACAJ,EAAAA,MAAM,CAACzC,YAAP;;AAEA;AACA,QAAM8C,eAAe,GAAGL,MAAM,CAACvF,aAAP,CAAqB,EAAEC,EAAE,EAAE,UAAN,EAAkBC,EAAE,EAAE,iBAAtB,EAArB,CAAxB;AACAqF,EAAAA,MAAM,CAACzC,YAAP;;AAEA;AACAvD,EAAAA,CAAC,CAACsG,iBAAF,CAAoBD,eAApB,EAAqCL,MAAM,CAAClG,cAA5C,EAA4D;AAC1DS,IAAAA,IAAI,EAAE,CAAC,GAAGyF,MAAM,CAACnG,YAAX,EAAyB,CAAzB,CADoD;AAE1D0G,IAAAA,GAAG,EAAEH,WAFqD,EAA5D;;AAID,CAlDH;;AAoDA3G,CAAC,CAAC0F,IAAF,CAAO,2BAAP;AACGC,IADH;AAEK;AACL,kHAHA;;AAKGuB,aALH;;AAOAlH,CAAC,CAAC0F,IAAF,CAAO,6BAAP;AACGC,IADH;AAEK;AACL,oHAHA;;AAKGuB,aALH","sourcesContent":["export const description = `\nMemory Synchronization Tests for Texture: read before write, read after write, and write after write to the same subresource.\n\n- TODO: Test synchronization between multiple queues.\n- TODO: Test depth/stencil attachments.\n- TODO: Use non-solid-color texture contents [2]\n`;\n\nimport { SkipTestCase } from '../../../../../common/framework/fixture.js';\nimport { makeTestGroup } from '../../../../../common/framework/test_group.js';\nimport { assert, memcpy, unreachable } from '../../../../../common/util/util.js';\nimport { EncodableTextureFormat } from '../../../../capability_info.js';\nimport { GPUTest } from '../../../../gpu_test.js';\nimport { align } from '../../../../util/math.js';\nimport { getTextureCopyLayout } from '../../../../util/texture/layout.js';\nimport {\n  kTexelRepresentationInfo,\n  PerTexelComponent,\n} from '../../../../util/texture/texel_data.js';\n\nimport {\n  kOperationBoundaries,\n  kBoundaryInfo,\n  kAllReadOps,\n  kAllWriteOps,\n  checkOpsValidForContext,\n  Op,\n  OperationBoundary,\n  OperationContext,\n  kOpInfo,\n  kOperationContexts,\n} from './texture_sync_test.js';\n\nexport const g = makeTestGroup(GPUTest);\n\nclass TextureSyncTestHelper {\n  // We start at the queue context which is top-level.\n  private currentContext: OperationContext = 'queue';\n\n  // Set based on the current context.\n  private queue: GPUQueue;\n  private commandEncoder?: GPUCommandEncoder;\n  private computePassEncoder?: GPUComputePassEncoder;\n  private renderPassEncoder?: GPURenderPassEncoder;\n  private renderBundleEncoder?: GPURenderBundleEncoder;\n\n  private t: GPUTest;\n  private device: GPUDevice;\n  private texture: GPUTexture;\n\n  private encodedCommands: GPURenderBundle[] | GPUCommandBuffer[] = [];\n\n  public readonly kTextureSize = [4, 4] as const;\n  public readonly kTextureFormat: EncodableTextureFormat = 'rgba8unorm';\n\n  constructor(\n    t: GPUTest,\n    textureCreationParams: {\n      usage: GPUTextureUsageFlags;\n    }\n  ) {\n    this.t = t;\n    this.device = t.device;\n    this.queue = t.device.queue;\n    this.texture = t.trackForCleanup(\n      t.device.createTexture({\n        size: this.kTextureSize,\n        format: this.kTextureFormat,\n        ...textureCreationParams,\n      })\n    );\n  }\n\n  /**\n   * Perform a read operation on the test texture.\n   * @return GPUTexture copy containing the contents.\n   */\n  performReadOp({ op, in: context }: { op: Op; in: OperationContext }): GPUTexture {\n    this.ensureContext(context);\n    switch (op) {\n      case 't2t-copy': {\n        const texture = this.t.trackForCleanup(\n          this.device.createTexture({\n            size: this.kTextureSize,\n            format: this.kTextureFormat,\n            usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n          })\n        );\n\n        assert(this.commandEncoder !== undefined);\n        this.commandEncoder.copyTextureToTexture(\n          {\n            texture: this.texture,\n          },\n          { texture },\n          this.kTextureSize\n        );\n        return texture;\n      }\n      case 't2b-copy': {\n        const { byteLength, bytesPerRow } = getTextureCopyLayout(this.kTextureFormat, '2d', [\n          ...this.kTextureSize,\n          1,\n        ]);\n        const buffer = this.t.trackForCleanup(\n          this.device.createBuffer({\n            size: byteLength,\n            usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n          })\n        );\n\n        const texture = this.t.trackForCleanup(\n          this.device.createTexture({\n            size: this.kTextureSize,\n            format: this.kTextureFormat,\n            usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n          })\n        );\n\n        assert(this.commandEncoder !== undefined);\n        this.commandEncoder.copyTextureToBuffer(\n          {\n            texture: this.texture,\n          },\n          { buffer, bytesPerRow },\n          this.kTextureSize\n        );\n        this.commandEncoder.copyBufferToTexture(\n          { buffer, bytesPerRow },\n          { texture },\n          this.kTextureSize\n        );\n        return texture;\n      }\n      case 'sample':\n      case 'storage':\n        // [1] Finish implementation\n        throw new SkipTestCase('unimplemented');\n        break;\n      case 'b2t-copy':\n      case 'attachment-resolve':\n      case 'attachment-store':\n        unreachable();\n    }\n    unreachable();\n  }\n\n  performWriteOp(\n    { op, in: context }: { op: Op; in: OperationContext },\n    data: PerTexelComponent<number>\n  ) {\n    this.ensureContext(context);\n    switch (op) {\n      case 'attachment-store': {\n        assert(this.commandEncoder !== undefined);\n        this.renderPassEncoder = this.commandEncoder.beginRenderPass({\n          colorAttachments: [\n            {\n              view: this.texture.createView(),\n              // [2] Use non-solid-color texture values\n              loadValue: [data.R ?? 0, data.G ?? 0, data.B ?? 0, data.A ?? 0],\n              storeOp: 'store',\n            },\n          ],\n        });\n        this.currentContext = 'render-pass-encoder';\n        break;\n      }\n      case 'write-texture': {\n        // [2] Use non-solid-color texture values\n        const rep = kTexelRepresentationInfo[this.kTextureFormat];\n        const texelData = rep.pack(rep.encode(data));\n        const numTexels = this.kTextureSize[0] * this.kTextureSize[1];\n        const fullTexelData = new ArrayBuffer(texelData.byteLength * numTexels);\n        for (let i = 0; i < numTexels; ++i) {\n          memcpy({ src: texelData }, { dst: fullTexelData, start: i * texelData.byteLength });\n        }\n\n        this.queue.writeTexture(\n          { texture: this.texture },\n          fullTexelData,\n          {\n            bytesPerRow: texelData.byteLength * this.kTextureSize[0],\n          },\n          this.kTextureSize\n        );\n        break;\n      }\n      case 't2t-copy': {\n        const texture = this.device.createTexture({\n          size: this.kTextureSize,\n          format: this.kTextureFormat,\n          usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n        });\n\n        // [2] Use non-solid-color texture values\n        const rep = kTexelRepresentationInfo[this.kTextureFormat];\n        const texelData = rep.pack(rep.encode(data));\n        const numTexels = this.kTextureSize[0] * this.kTextureSize[1];\n        const fullTexelData = new ArrayBuffer(texelData.byteLength * numTexels);\n        for (let i = 0; i < numTexels; ++i) {\n          memcpy({ src: texelData }, { dst: fullTexelData, start: i * texelData.byteLength });\n        }\n\n        this.queue.writeTexture(\n          { texture },\n          fullTexelData,\n          {\n            bytesPerRow: texelData.byteLength * this.kTextureSize[0],\n          },\n          this.kTextureSize\n        );\n\n        assert(this.commandEncoder !== undefined);\n        this.commandEncoder.copyTextureToTexture(\n          { texture },\n          { texture: this.texture },\n          this.kTextureSize\n        );\n        break;\n      }\n      case 'b2t-copy': {\n        // [2] Use non-solid-color texture values\n        const rep = kTexelRepresentationInfo[this.kTextureFormat];\n        const texelData = rep.pack(rep.encode(data));\n        const bytesPerRow = align(texelData.byteLength, 256);\n        const fullTexelData = new ArrayBuffer(bytesPerRow * this.kTextureSize[1]);\n        for (let i = 0; i < this.kTextureSize[1]; ++i) {\n          for (let j = 0; j < this.kTextureSize[0]; ++j) {\n            memcpy(\n              { src: texelData },\n              {\n                dst: fullTexelData,\n                start: i * bytesPerRow + j * texelData.byteLength,\n              }\n            );\n          }\n        }\n\n        const buffer = this.t.trackForCleanup(\n          this.device.createBuffer({\n            size: fullTexelData.byteLength,\n            usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n          })\n        );\n\n        this.queue.writeBuffer(buffer, 0, fullTexelData);\n\n        assert(this.commandEncoder !== undefined);\n        this.commandEncoder.copyBufferToTexture(\n          { buffer, bytesPerRow },\n          { texture: this.texture },\n          this.kTextureSize\n        );\n        break;\n      }\n      case 'attachment-resolve':\n      case 'storage':\n        // [1] Finish implementation\n        throw new SkipTestCase('unimplemented');\n      case 't2b-copy':\n      case 'sample':\n        unreachable();\n    }\n  }\n\n  // Ensure that all encoded commands are finished and subitted.\n  ensureSubmit() {\n    this.ensureContext('queue');\n    this.flushEncodedCommands();\n  }\n\n  private popContext(): GPURenderBundle | GPUCommandBuffer | null {\n    switch (this.currentContext) {\n      case 'queue':\n        unreachable();\n        break;\n      case 'command-encoder': {\n        assert(this.commandEncoder !== undefined);\n        const commandBuffer = this.commandEncoder.finish();\n        this.commandEncoder = undefined;\n        this.currentContext = 'queue';\n        return commandBuffer;\n      }\n      case 'compute-pass-encoder':\n        assert(this.computePassEncoder !== undefined);\n        this.computePassEncoder.endPass();\n        this.computePassEncoder = undefined;\n        this.currentContext = 'command-encoder';\n        break;\n      case 'render-pass-encoder':\n        assert(this.renderPassEncoder !== undefined);\n        this.renderPassEncoder.endPass();\n        this.renderPassEncoder = undefined;\n        this.currentContext = 'command-encoder';\n        break;\n      case 'render-bundle-encoder': {\n        assert(this.renderBundleEncoder !== undefined);\n        const renderBundle = this.renderBundleEncoder.finish();\n        this.renderBundleEncoder = undefined;\n        this.currentContext = 'render-pass-encoder';\n        return renderBundle;\n      }\n    }\n    return null;\n  }\n\n  private makeDummyAttachment(): GPURenderPassColorAttachment {\n    const texture = this.t.trackForCleanup(\n      this.device.createTexture({\n        format: this.kTextureFormat,\n        size: this.kTextureSize,\n        usage: GPUTextureUsage.RENDER_ATTACHMENT,\n      })\n    );\n    return {\n      view: texture.createView(),\n      loadValue: 'load',\n      storeOp: 'store',\n    };\n  }\n\n  private ensureContext(context: OperationContext) {\n    // Find the common ancestor. So we can transition from currentContext -> context.\n    const ancestorContext =\n      kOperationContexts[\n        Math.min(\n          kOperationContexts.indexOf(context),\n          kOperationContexts.indexOf(this.currentContext)\n        )\n      ];\n\n    // Pop the context until we're at the common ancestor.\n    while (this.currentContext !== ancestorContext) {\n      // About to pop the render pass encoder. Execute any outstanding render bundles.\n      if (this.currentContext === 'render-pass-encoder') {\n        this.flushEncodedCommands();\n      }\n\n      const result = this.popContext();\n      if (result) {\n        if (result instanceof GPURenderBundle) {\n          assert(\n            this.encodedCommands.length === 0 || this.encodedCommands[0] instanceof GPURenderBundle\n          );\n          (this.encodedCommands as GPURenderBundle[]).push(result);\n        } else {\n          assert(\n            this.encodedCommands.length === 0 || this.encodedCommands[0] instanceof GPUCommandBuffer\n          );\n          (this.encodedCommands as GPUCommandBuffer[]).push(result);\n        }\n      }\n    }\n\n    if (this.currentContext === context) {\n      return;\n    }\n\n    switch (context) {\n      case 'queue':\n        unreachable();\n        break;\n      case 'command-encoder':\n        assert(this.currentContext === 'queue');\n        this.commandEncoder = this.device.createCommandEncoder();\n        break;\n      case 'compute-pass-encoder':\n        switch (this.currentContext) {\n          case 'queue':\n            this.commandEncoder = this.device.createCommandEncoder();\n          // fallthrough\n          case 'command-encoder':\n            assert(this.commandEncoder !== undefined);\n            this.computePassEncoder = this.commandEncoder.beginComputePass();\n            break;\n          case 'compute-pass-encoder':\n          case 'render-bundle-encoder':\n          case 'render-pass-encoder':\n            unreachable();\n        }\n        break;\n      case 'render-pass-encoder':\n        switch (this.currentContext) {\n          case 'queue':\n            this.commandEncoder = this.device.createCommandEncoder();\n          // fallthrough\n          case 'command-encoder':\n            assert(this.commandEncoder !== undefined);\n            this.renderPassEncoder = this.commandEncoder.beginRenderPass({\n              colorAttachments: [this.makeDummyAttachment()],\n            });\n            break;\n          case 'render-pass-encoder':\n          case 'render-bundle-encoder':\n          case 'compute-pass-encoder':\n            unreachable();\n        }\n        break;\n      case 'render-bundle-encoder':\n        switch (this.currentContext) {\n          case 'queue':\n            this.commandEncoder = this.device.createCommandEncoder();\n          // fallthrough\n          case 'command-encoder':\n            assert(this.commandEncoder !== undefined);\n            this.renderPassEncoder = this.commandEncoder.beginRenderPass({\n              colorAttachments: [this.makeDummyAttachment()],\n            });\n          // fallthrough\n          case 'render-pass-encoder':\n            this.renderBundleEncoder = this.device.createRenderBundleEncoder({\n              colorFormats: [this.kTextureFormat],\n            });\n            break;\n          case 'render-bundle-encoder':\n          case 'compute-pass-encoder':\n            unreachable();\n        }\n        break;\n    }\n    this.currentContext = context;\n  }\n\n  /**\n   * Execute/submit encoded GPURenderBundles or GPUCommandBuffers.\n   */\n  private flushEncodedCommands() {\n    if (this.encodedCommands.length > 0) {\n      if (this.encodedCommands[0] instanceof GPURenderBundle) {\n        assert(this.renderPassEncoder !== undefined);\n        this.renderPassEncoder.executeBundles(this.encodedCommands as GPURenderBundle[]);\n      } else {\n        this.queue.submit(this.encodedCommands as GPUCommandBuffer[]);\n      }\n    }\n    this.encodedCommands = [];\n  }\n\n  ensureBoundary(boundary: OperationBoundary) {\n    switch (boundary) {\n      case 'command-buffer':\n        this.ensureContext('queue');\n        break;\n      case 'queue-op':\n        this.ensureContext('queue');\n        // Submit any GPUCommandBuffers so the next one is in a separate submit.\n        this.flushEncodedCommands();\n        break;\n      case 'dispatch':\n        // Nothing to do to separate dispatches.\n        assert(this.currentContext === 'compute-pass-encoder');\n        break;\n      case 'draw':\n        // Nothing to do to separate draws.\n        assert(\n          this.currentContext === 'render-pass-encoder' ||\n            this.currentContext === 'render-bundle-encoder'\n        );\n        break;\n      case 'pass':\n        this.ensureContext('command-encoder');\n        break;\n      case 'render-bundle':\n        this.ensureContext('render-pass-encoder');\n        break;\n      case 'execute-bundles':\n        this.ensureContext('render-pass-encoder');\n        // Execute any GPURenderBundles so the next one is in a separate executeBundles.\n        this.flushEncodedCommands();\n        break;\n    }\n  }\n}\n\ng.test('rw')\n  .desc(\n    `\n    Perform a 'read' operations on a texture subresource, followed by a 'write' operation.\n    Operations are separated by a 'boundary' (pass, encoder, queue-op, etc.).\n    Test that the results are synchronized.\n    The read should not see the contents written by the subsequent write.`\n  )\n  .params(u =>\n    u\n      .combine('boundary', kOperationBoundaries)\n      .expand('_context', p => kBoundaryInfo[p.boundary].contexts)\n      .expandWithParams(function* ({ _context }) {\n        for (const read of kAllReadOps) {\n          for (const write of kAllWriteOps) {\n            if (checkOpsValidForContext([read, write], _context)) {\n              yield {\n                read: { op: read, in: _context[0] },\n                write: { op: write, in: _context[1] },\n              };\n            }\n          }\n        }\n      })\n  )\n  .fn(t => {\n    const helper = new TextureSyncTestHelper(t, {\n      usage:\n        GPUTextureUsage.COPY_DST |\n        kOpInfo[t.params.read.op].readUsage |\n        kOpInfo[t.params.write.op].writeUsage,\n    });\n    // [2] Use non-solid-color texture value.\n    const texelValue1 = { R: 0, G: 1, B: 0, A: 1 } as const;\n    const texelValue2 = { R: 1, G: 0, B: 0, A: 1 } as const;\n\n    // Initialize the texture with something.\n    helper.performWriteOp({ op: 'write-texture', in: 'queue' }, texelValue1);\n    const readbackTexture = helper.performReadOp(t.params.read);\n    helper.ensureBoundary(t.params.boundary);\n    helper.performWriteOp(t.params.write, texelValue2);\n    helper.ensureSubmit();\n\n    // Contents should be the first value written, not the second.\n    t.expectSingleColor(readbackTexture, helper.kTextureFormat, {\n      size: [...helper.kTextureSize, 1],\n      exp: texelValue1,\n    });\n  });\n\ng.test('wr')\n  .desc(\n    `\n    Perform a 'write' operation on a texture subresource, followed by a 'read' operation.\n    Operations are separated by a 'boundary' (pass, encoder, queue-op, etc.).\n    Test that the results are synchronized.\n    The read should see exactly the contents written by the previous write.\n\n    - TODO: Finish implementation [1]\n    - TODO: Use non-solid-color texture contents [2]`\n  )\n  .params(u =>\n    u\n      .combine('boundary', kOperationBoundaries)\n      .expand('_context', p => kBoundaryInfo[p.boundary].contexts)\n      .expandWithParams(function* ({ _context }) {\n        for (const read of kAllReadOps) {\n          for (const write of kAllWriteOps) {\n            if (checkOpsValidForContext([write, read], _context)) {\n              yield {\n                write: { op: write, in: _context[0] },\n                read: { op: read, in: _context[1] },\n              };\n            }\n          }\n        }\n      })\n  )\n  .fn(t => {\n    const helper = new TextureSyncTestHelper(t, {\n      usage: kOpInfo[t.params.read.op].readUsage | kOpInfo[t.params.write.op].writeUsage,\n    });\n    // [2] Use non-solid-color texture value.\n    const texelValue = { R: 0, G: 1, B: 0, A: 1 } as const;\n\n    helper.performWriteOp(t.params.write, texelValue);\n    helper.ensureBoundary(t.params.boundary);\n    const readbackTexture = helper.performReadOp(t.params.read);\n    helper.ensureSubmit();\n\n    // Contents should be exactly the values written.\n    t.expectSingleColor(readbackTexture, helper.kTextureFormat, {\n      size: [...helper.kTextureSize, 1],\n      exp: texelValue,\n    });\n  });\n\ng.test('ww')\n  .desc(\n    `\n    Perform a 'first' write operation on a texture subresource, followed by a 'second' write operation.\n    Operations are separated by a 'boundary' (pass, encoder, queue-op, etc.).\n    Test that the results are synchronized.\n    The second write should overwrite the contents of the first.`\n  )\n  .params(u =>\n    u\n      .combine('boundary', kOperationBoundaries)\n      .expand('_context', p => kBoundaryInfo[p.boundary].contexts)\n      .expandWithParams(function* ({ _context }) {\n        for (const first of kAllWriteOps) {\n          for (const second of kAllWriteOps) {\n            if (checkOpsValidForContext([first, second], _context)) {\n              yield {\n                first: { op: first, in: _context[0] },\n                second: { op: second, in: _context[1] },\n              };\n            }\n          }\n        }\n      })\n  )\n  .fn(t => {\n    const helper = new TextureSyncTestHelper(t, {\n      usage:\n        GPUTextureUsage.COPY_SRC |\n        kOpInfo[t.params.first.op].writeUsage |\n        kOpInfo[t.params.second.op].writeUsage,\n    });\n    // [2] Use non-solid-color texture value.\n    const texelValue1 = { R: 1, G: 0, B: 0, A: 1 } as const;\n    const texelValue2 = { R: 0, G: 1, B: 0, A: 1 } as const;\n\n    helper.performWriteOp(t.params.first, texelValue1);\n    helper.ensureBoundary(t.params.boundary);\n    helper.performWriteOp(t.params.second, texelValue2);\n    helper.ensureSubmit();\n\n    // Read back the contents so we can test the result.\n    const readbackTexture = helper.performReadOp({ op: 't2t-copy', in: 'command-encoder' });\n    helper.ensureSubmit();\n\n    // Contents should be the second value written.\n    t.expectSingleColor(readbackTexture, helper.kTextureFormat, {\n      size: [...helper.kTextureSize, 1],\n      exp: texelValue2,\n    });\n  });\n\ng.test('rw,single_pass,load_store')\n  .desc(\n    `\n    TODO: Test memory synchronization when loading from a texture subresource in a single pass and storing to it.`\n  )\n  .unimplemented();\n\ng.test('rw,single_pass,load_resolve')\n  .desc(\n    `\n    TODO: Test memory synchronization when loading from a texture subresource in a single pass and resolving to it.`\n  )\n  .unimplemented();\n"],"file":"same_subresource.spec.js"}