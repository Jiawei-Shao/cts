{"version":3,"sources":["../../../../../src/webgpu/shader/execution/memory_model/weak.spec.ts"],"names":["description","makeTestGroup","GPUTest","MemoryModelTester","buildIntraWorkgroupTestShader","buildFourResultShader","g","memoryModelTestParams","workgroupSize","testingWorkgroups","maxWorkgroups","shufflePct","barrierPct","memStressPct","memStressIterations","memStressStoreFirstPct","memStressStoreSecondPct","preStressPct","preStressIterations","preStressStoreFirstPct","preStressStoreSecondPct","scratchMemorySize","stressLineSize","stressTargetLines","stressStrategyBalancePct","permuteFirst","permuteSecond","memStride","aliasedMemory","numMemLocations","numReadOutputs","numBehaviors","test","desc","fn","t","testCode","resultCode","testShader","resultShader","memModelTester","run"],"mappings":";AAAA;AACA,GADA,OAAO,MAAMA,WAAW,GAAI;AAC5B;AACA;AACA,6DAHO,CAKP,SAASC,aAAT,QAA8B,4CAA9B;AACA,SAASC,OAAT,QAAwB,sBAAxB;;AAEA;;AAEEC,iBAFF;AAGEC,6BAHF;AAIEC,qBAJF;AAKO,yBALP;;AAOA,OAAO,MAAMC,CAAC,GAAGL,aAAa,CAACC,OAAD,CAAvB;;AAEP;AACA,MAAMK,qBAA4C,GAAG;AACnDC,EAAAA,aAAa,EAAE,GADoC;AAEnDC,EAAAA,iBAAiB,EAAE,GAFgC;AAGnDC,EAAAA,aAAa,EAAE,IAHoC;AAInDC,EAAAA,UAAU,EAAE,GAJuC;AAKnDC,EAAAA,UAAU,EAAE,GALuC;AAMnDC,EAAAA,YAAY,EAAE,GANqC;AAOnDC,EAAAA,mBAAmB,EAAE,IAP8B;AAQnDC,EAAAA,sBAAsB,EAAE,EAR2B;AASnDC,EAAAA,uBAAuB,EAAE,EAT0B;AAUnDC,EAAAA,YAAY,EAAE,GAVqC;AAWnDC,EAAAA,mBAAmB,EAAE,IAX8B;AAYnDC,EAAAA,sBAAsB,EAAE,EAZ2B;AAanDC,EAAAA,uBAAuB,EAAE,EAb0B;AAcnDC,EAAAA,iBAAiB,EAAE,IAdgC;AAenDC,EAAAA,cAAc,EAAE,EAfmC;AAgBnDC,EAAAA,iBAAiB,EAAE,CAhBgC;AAiBnDC,EAAAA,wBAAwB,EAAE,EAjByB;AAkBnDC,EAAAA,YAAY,EAAE,GAlBqC;AAmBnDC,EAAAA,aAAa,EAAE,GAnBoC;AAoBnDC,EAAAA,SAAS,EAAE,CApBwC;AAqBnDC,EAAAA,aAAa,EAAE,KArBoC;AAsBnDC,EAAAA,eAAe,EAAE,CAtBkC;AAuBnDC,EAAAA,cAAc,EAAE,CAvBmC;AAwBnDC,EAAAA,YAAY,EAAE,CAxBqC,EAArD;;;AA2BAzB,CAAC,CAAC0B,IAAF,CAAO,kCAAP;AACGC,IADH;AAEK;AACL;AACA;AACA;AACA;AACA;AACA,KARA;;AAUGC,EAVH,CAUM,MAAMC,CAAN,IAAW;AACb,QAAMC,QAAQ,GAAI;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAvBI;AAwBA,QAAMC,UAAU,GAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAbI;;AAeA,QAAMC,UAAU,GAAGlC,6BAA6B,CAACgC,QAAD,CAAhD;AACA,QAAMG,YAAY,GAAGlC,qBAAqB,CAACgC,UAAD,CAA1C;AACA,QAAMG,cAAc,GAAG,IAAIrC,iBAAJ;AACrBgC,EAAAA,CADqB;AAErB5B,EAAAA,qBAFqB;AAGrB+B,EAAAA,UAHqB;AAIrBC,EAAAA,YAJqB,CAAvB;;AAMA,QAAMC,cAAc,CAACC,GAAf,CAAmB,EAAnB,EAAuB,CAAvB,CAAN;AACD,CA3DH","sourcesContent":["export const description = `\nTests for properties of the WebGPU memory model involving two memory locations.\nSpecifically, the acquire/release ordering provided by WebGPU's barriers can be used to disallow\nweak behaviors in several classic memory model litmus tests.`;\n\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport { GPUTest } from '../../../gpu_test.js';\n\nimport {\n  MemoryModelTestParams,\n  MemoryModelTester,\n  buildIntraWorkgroupTestShader,\n  buildFourResultShader,\n} from './memory_model_setup.js';\n\nexport const g = makeTestGroup(GPUTest);\n\n// A reasonable parameter set, determined heuristically.\nconst memoryModelTestParams: MemoryModelTestParams = {\n  workgroupSize: 256,\n  testingWorkgroups: 512,\n  maxWorkgroups: 1024,\n  shufflePct: 100,\n  barrierPct: 100,\n  memStressPct: 100,\n  memStressIterations: 1024,\n  memStressStoreFirstPct: 50,\n  memStressStoreSecondPct: 50,\n  preStressPct: 100,\n  preStressIterations: 1024,\n  preStressStoreFirstPct: 50,\n  preStressStoreSecondPct: 50,\n  scratchMemorySize: 2048,\n  stressLineSize: 64,\n  stressTargetLines: 2,\n  stressStrategyBalancePct: 50,\n  permuteFirst: 109,\n  permuteSecond: 419,\n  memStride: 4,\n  aliasedMemory: false,\n  numMemLocations: 2,\n  numReadOutputs: 2,\n  numBehaviors: 4,\n};\n\ng.test('message_passing_workgroup_memory')\n  .desc(\n    `Checks whether two reads on one thread can observe two writes in another thread in a way\n    that is inconsistent with sequential consistency. In the message passing litmus test, one\n    thread writes the value 1 to some location x and then 1 to some location y. The second thread\n    reads y and then x. If the second thread reads y == 1 and x == 0, then sequential consistency\n    has not been respected. The acquire/release semantics of WebGPU's workgroupBarrier() should disallow\n    this behavior within a workgroup.\n    `\n  )\n  .fn(async t => {\n    const testCode = `\n        let total_ids = workgroupXSize;\n        let id_0 = local_invocation_id[0];\n        let id_1 = permute_id(local_invocation_id[0], stress_params.permute_first, workgroupXSize);\n        let x_0 = (id_0) * stress_params.mem_stride * 2u;\n        let y_0 = (permute_id(id_0, stress_params.permute_second, total_ids)) * stress_params.mem_stride * 2u + stress_params.location_offset;\n        let y_1 = (permute_id(id_1, stress_params.permute_second, total_ids)) * stress_params.mem_stride * 2u + stress_params.location_offset;\n        let x_1 = (id_1) * stress_params.mem_stride * 2u;\n        if (stress_params.pre_stress == 1u) {\n          do_stress(stress_params.pre_stress_iterations, stress_params.pre_stress_pattern, shuffled_workgroup);\n        }\n        if (stress_params.do_barrier == 1u) {\n          spin(workgroupXSize);\n        }\n        atomicStore(&wg_test_locations[x_0], 1u);\n        workgroupBarrier();\n        atomicStore(&wg_test_locations[y_0], 1u);\n        let r0 = atomicLoad(&wg_test_locations[y_1]);\n        workgroupBarrier();\n        let r1 = atomicLoad(&wg_test_locations[x_1]);\n        workgroupBarrier();\n        atomicStore(&results.value[shuffled_workgroup * workgroupXSize + id_1].r0, r0);\n        atomicStore(&results.value[shuffled_workgroup * workgroupXSize + id_1].r1, r1);\n    `;\n    const resultCode = `\n      let id_0 = workgroup_id[0] * workgroupXSize + local_invocation_id[0];\n      let r0 = atomicLoad(&read_results.value[id_0].r0);\n      let r1 = atomicLoad(&read_results.value[id_0].r1);\n      if ((r0 == 0u && r1 == 0u)) {\n        atomicAdd(&test_results.seq0, 1u);\n      } else if ((r0 == 1u && r1 == 1u)) {\n        atomicAdd(&test_results.seq1, 1u);\n      } else if ((r0 == 0u && r1 == 1u)) {\n        atomicAdd(&test_results.interleaved, 1u);\n      } else if ((r0 == 1u && r1 == 0u)) {\n        atomicAdd(&test_results.weak, 1u);\n      }\n    `;\n\n    const testShader = buildIntraWorkgroupTestShader(testCode);\n    const resultShader = buildFourResultShader(resultCode);\n    const memModelTester = new MemoryModelTester(\n      t,\n      memoryModelTestParams,\n      testShader,\n      resultShader\n    );\n    await memModelTester.run(20, 3);\n  });\n"],"file":"weak.spec.js"}